# EHC 项目代码架构分析与重构方案

> 分析日期：2026-02-14
> 重构完成日期：2026-02-14
> 分析范围：scripts/ 目录下所有 GDScript 文件

---

## 重构完成情况

✅ **重构状态：已完成**

### 已完成的重构内容

1. **Manager 单例架构** - 创建了 5 个 Manager 单例：
   - `PlayerManager` - 玩家实体管理和统一伤害接口
   - `GameManager` - 游戏流程和关卡切换管理
   - `LevelManager` - 关卡状态、敌人、存档点管理
   - `SaveManager` - 存档文件读写系统
   - `UIManager` - UI 面板管理和 HUD 数据同步

2. **代码解耦** - 敌人/陷阱脚本改用 `PlayerManager.apply_damage()`，不再直接访问玩家节点结构

3. **场景切换集中管理** - 所有场景切换通过 `GameManager` 处理

4. **文件目录重组** - 按功能分类整理到对应子目录

### 文件结构变更

```
scripts/
├── autoload/          # Manager 单例（已创建）
├── player/            # 玩家相关（已归纳）
├── enemies/           # 敌人相关（已归纳）
├── hazards/           # 陷阱相关（已归纳）
├── ui/                # UI 相关（已归纳）
├── scene/             # 场景调度相关（占位）
├── utils/             # 工具类（已创建）
└── global.gd          # 旧全局配置（保留待移除）
```

---

## 一、现有模块梳理

### 1.1 Autoload 单例（全局节点）

| 单例名 | 脚本路径 | 职责 |
|--------|----------|------|
| `Global_settings` | `scripts/global.gd` | 全局重力配置 |
| `Playerstates` | `scripts/Playerstates.gd` | 玩家状态管理（生命、体力、异常状态） |

### 1.2 核心实体脚本

| 脚本 | 类型 | 职责 |
|------|------|------|
| `player.gd` | `CharacterBody2D` | 玩家控制器：移动、跳跃、二段跳、击飞响应、游戏结束处理 |
| `whitecell.gd` | `CharacterBody2D` | 敌人（白细胞）：巡逻移动、正弦波垂直运动、发射子弹 |
| `wc_bullets.gd` | `CharacterBody2D` | 敌人子弹：直线飞行、碰撞检测、对玩家造成伤害 |

### 1.3 场景/关卡元素

| 脚本 | 类型 | 职责 |
|------|------|------|
| `spike.gd` | `Area2D` | 尖刺陷阱：触碰检测、调用玩家受伤逻辑 |
| `sticky_poor.gd` | `Area2D` | 粘液池：触碰检测、伤害+击飞、施加"粘液"异常状态 |
| `title.gd` | `Control` | 标题界面：开始游戏、退出游戏 |
| `gameclear.gd` | `Area2D` | 通关区域：进入后返回标题 |
| `control.gd` | `Control` | 空脚本（未实现） |

---

## 二、当前架构问题分析

### 2.1 高度耦合的问题

#### 问题1：敌人/陷阱直接操作玩家节点结构
**影响文件**：`spike.gd`, `sticky_poor.gd`, `whitecell.gd`, `wc_bullets.gd`

```gdscript
# 所有敌人都使用这种硬编码方式访问玩家
var player_state = body.get_node('state')
if player_state and player_state.has_method('take_damage'):
    var force = player_state.take_damage(1, 20, 1500)
if body.has_method("apply_knockback"):
    body.apply_knockback(force)
```

**问题**：
- 假设玩家节点一定有名为 `state` 的子节点
- 假设 `state` 节点有 `take_damage` 方法
- 假设玩家有 `apply_knockback` 方法
- 玩家结构调整会导致所有敌人/陷阱脚本失效

#### 问题2：混合职责 - PlayerState 越界
**影响文件**：`Playerstates.gd`

当前 `PlayerState` 类做了太多事情：
- ✅ 合理的：管理 cloth/stamina 数值、状态计时器
- ❌ 不合理的：直接处理"受到攻击时的击飞力度计算"

击飞逻辑应该属于**玩家控制器**，状态机只应返回"是否应该击飞"和"击飞强度系数"，而不是直接计算最终力度。

#### 问题3：场景切换散落各处
**影响文件**：`title.gd`, `gameclear.gd`, `player.gd`

```gdscript
# title.gd
get_tree().change_scene_to_file("res://scenes/Levels/testlevel_playermovement.tscn")

# gameclear.gd
get_tree().change_scene_to_file("res://scenes/title.tscn")

# player.gd
get_tree().change_scene_to_file("res://scenes/title.tscn")
```

**问题**：场景路径硬编码，无法统一管理场景过渡效果、加载界面、存档点记录。

#### 问题4：玩家控制器职责过重
**影响文件**：`player.gd`

当前 `player.gd` 同时处理：
1. 输入处理（移动、跳跃）
2. 物理计算（速度、摩擦力、重力）
3. 游戏结束检测与处理
4. 击飞效果应用
5. 异常状态对移动的影响（粘液状态摩擦系数）

**问题**：违反单一职责原则，随着功能增加会越来越臃肿。

#### 问题5：敌人生成耦合于场景树
**影响文件**：`whitecell.gd`

```gdscript
get_tree().current_scene.add_child(bullet)
```

**问题**：直接操作场景树，没有通过任何管理器，难以做对象池、性能监控、统一销毁。

#### 问题6：全局重力单例设计不当
**影响文件**：`global.gd`

```gdscript
# global.gd
extends Node2D  # ❌ 继承 Node2D 没有必要

func gravity() -> Vector2:
    return Vector2.DOWN.normalized() * base_gravity  # ❌ 每帧计算
```

**问题**：
- 继承 `Node2D` 没有必要，纯数据类应继承 `Node` 或 `@tool`
- `Vector2.DOWN` 已经是 `(0, 1)`，不需要 `.normalized()`
- 重力值应该是常量，不需要每帧计算

---

## 三、Manager 单例范式重构方案

### 3.1 目标架构图（Node Tree 形式）

```
[Godot Scene Tree]
│
├── [Autoload Singletons]  (自动加载，全局可访问)
│   ├── GameManager        (游戏流程 + 关卡切换)
│   ├── PlayerManager      (玩家实体管理)
│   ├── LevelManager       (关卡状态)
│   ├── SaveManager        (存档系统)
│   └── UIManager          (UI 管理)
│
├── [Root]
│   ├── title.tscn         (标题场景)
│   │   └── TitleScreen    (无需SceneManager)
│   │
│   └── Level_XXX.tscn     (关卡场景)
│       ├── SceneManager   (继承自基类的场景调度器，可选)
│       │   └── 管理场景内事件、演出、时序
│       ├── Player         (玩家实体)
│       │   ├── PlayerController
│       │   └── PlayerState
│       ├── Enemies        (敌人容器)
│       │   ├── WhiteCell
│       │   └── ...
│       ├── Hazards        (陷阱容器)
│       │   ├── Spike
│       │   └── StickyPool
│       └── LevelGeometry  (地形、背景)
│
└── [Persistent Data]
    └── save.json          (存档文件)
```

### 3.2 Manager 职责定义

#### 3.2.1 GameManager（游戏流程与关卡管理）
```gdscript
# scripts/managers/game_manager.gd
extends Node

enum GameState { TITLE, PLAYING, PAUSED, GAME_OVER, VICTORY }

var current_state: GameState = GameState.TITLE
var current_level: int = 1
var level_scenes: Dictionary = {}  # 关卡ID到场景路径的映射

# 游戏流程控制
func start_game() -> void
func pause_game() -> void
func resume_game() -> void
func game_over() -> void
func return_to_title() -> void
func get_current_state() -> GameState

# 关卡切换
func load_level(level_id: String) -> void
func reload_current_level() -> void
func get_current_level() -> String
func register_level(level_id: String, scene_path: String) -> void
```

**职责**：
- 管理游戏整体状态机（标题、游戏中、暂停、结束）
- **关卡切换管理**：注册关卡、加载指定关卡、重载当前关卡
- 协调其他 Manager 的工作
- 处理游戏开始/结束/返回标题的高层级逻辑

#### 3.2.2 SceneManager（场景内调度基类）
```gdscript
# scripts/managers/scene_manager.gd
class_name SceneManager
extends Node

# 场景生命周期
func _on_scene_enter() -> void      # 场景进入时调用
func _on_scene_ready() -> void      # 场景准备好后调用
func _on_scene_exit() -> void       # 场景退出前调用

# 场景内事件调度（子类可重写）
func trigger_event(event_name: String, params: Dictionary = {}) -> void
func play_sequence(sequence_name: String) -> void
func pause_scene() -> void
func resume_scene() -> void
```

**说明**：
- `SceneManager` 是每个场景内部的调度器，**不是全局单例**
- 需要场景调度的关卡/场景，从此基类继承实现自己的版本
- 负责场景级别的事件、演出、时序控制等
- 目前作为占位符，有需要时再具体实现

**使用方式**：
```gdscript
# 具体关卡的场景管理器
extends SceneManager

func _on_scene_enter():
    # 关卡开始时的初始化
    pass

func trigger_event(event_name: String, params: Dictionary = {}):
    match event_name:
        "door_open":
            # 播放开门演出
            pass
        "boss_appear":
            # Boss出场动画
            pass
```

#### 3.2.3 PlayerManager（玩家实体管理）
```gdscript
# scripts/managers/player_manager.gd
extends Node

signal player_spawned(player: CharacterBody2D)
signal player_died

var player_instance: CharacterBody2D = null
var spawn_point: Vector2 = Vector2.ZERO

func register_player(player: CharacterBody2D) -> void
func unregister_player() -> void
func get_player() -> CharacterBody2D
func get_player_state() -> PlayerState
func set_spawn_point(pos: Vector2) -> void
func respawn_player() -> void
func apply_damage(damage_data: Dictionary) -> void
```

**职责**：
- 管理玩家实例的全局引用（安全的单例访问）
- 处理玩家生成/重生逻辑
- 提供统一接口供敌人/陷阱调用伤害
- 记录存档点位置

#### 3.2.4 LevelManager（关卡状态管理）
```gdscript
# scripts/managers/level_manager.gd
extends Node

signal level_completed
signal checkpoint_reached(position: Vector2)

var enemies: Array[Node] = []
var collectibles: Array[Node] = []
var current_checkpoint: Vector2 = Vector2.ZERO

func register_enemy(enemy: Node) -> void
func unregister_enemy(enemy: Node) -> void
func get_all_enemies() -> Array[Node]
func set_checkpoint(pos: Vector2) -> void
func complete_level() -> void
```

**职责**：
- 管理当前关卡内的所有动态对象（敌人、可收集物）
- 处理关卡完成逻辑
- 管理存档点（checkpoints）
- 关卡内对象的生命周期管理

#### 3.2.5 SaveManager（存档系统）
```gdscript
# scripts/managers/save_manager.gd
extends Node

const SAVE_PATH = "user://save.json"

var current_save: Dictionary = {}

func save_game() -> void
func load_game() -> bool
func delete_save() -> void
func has_save() -> bool
func get_last_level() -> String
func set_last_checkpoint(pos: Vector2) -> void
```

**职责**：
- 存档文件的读写
- 存档数据结构的版本管理
- 自动存档/手动存档控制

#### 3.2.6 UIManager（UI 管理）
```gdscript
# scripts/managers/ui_manager.gd
extends Node

enum UILayer { BACKGROUND, GAME, HUD, POPUP, OVERLAY, TOP }

var open_panels: Dictionary = {}  # 已打开的界面
var ui_stack: Array[Control] = [] # 界面导航栈

# 面板管理
func open_panel(panel_name: String, params: Dictionary = {}) -> void
func close_panel(panel_name: String) -> void
func close_all_panels() -> void
func get_panel(panel_name: String) -> Control
func is_panel_open(panel_name: String) -> bool

# 数据同步
func update_hud(data_type: String, value: Variant) -> void
func refresh_ui() -> void

# 导航控制
func push_ui_state(panel_name: String) -> void
func pop_ui_state() -> void

# 通用控件
func show_message(text: String, duration: float = 2.0) -> void
func show_confirm(title: String, message: String, callback: Callable) -> void
func show_loading(text: String = "Loading...") -> void
func hide_loading() -> void
```

**职责**：
- **UI 显示控制**：管理所有 UI 面板的打开/关闭（主菜单、HUD、设置、暂停菜单等）
- **层级管理**：使用层级的概念管理 UI 显示顺序（背景、游戏、HUD、弹窗、覆盖层、顶层）
- **数据同步**：接收来自 PlayerManager、LevelManager 的数据更新，同步到 HUD
- **导航栈**：实现 UI 返回功能（如设置界面返回主菜单）
- **通用控件**：提供消息提示、确认框、加载遮罩等通用功能

**与其他 Manager 的协作**：
```gdscript
# GameManager 切换状态时通知 UIManager
func _on_game_state_changed(new_state):
    match new_state:
        GameState.PLAYING:
            UIManager.open_panel("hud")
            UIManager.close_panel("main_menu")
        GameState.PAUSED:
            UIManager.open_panel("pause_menu")

# PlayerManager 更新玩家状态时通知 UIManager
func _on_player_cloth_changed(current, maximum):
    UIManager.update_hud("cloth", current)

# LevelManager 完成关卡时通知 UIManager
func _on_level_completed():
    UIManager.open_panel("level_complete")
```

---

### 3.3 现有脚本的重构路径

#### Phase 1: 解耦玩家相关操作（高优先级）

**步骤1：创建 PlayerManager**
- 创建 `scripts/managers/player_manager.gd`
- 实现 `register_player` / `get_player` 机制
- 实现 `apply_damage(damage_data)` 统一接口

**步骤2：重构敌人/陷阱脚本**
- 将 `spike.gd`, `sticky_poor.gd`, `wc_bullets.gd` 中的伤害逻辑改为：
```gdscript
# 重构前
var player_state = body.get_node('state')
if player_state.has_method('take_damage'):
    var force = player_state.take_damage(1, 20, 1500)
body.apply_knockback(force)

# 重构后
if body.is_in_group('Player'):
    PlayerManager.apply_damage({
        "cloth_damage": 1,
        "stamina_damage": 20,
        "knockback_force": 1500,
        "knockback_direction": Vector2(-1, -0.4)
    })
```

**步骤3：重构 PlayerState**
- 移除 `take_damage` 中的击飞力度计算
- 只负责数值计算和状态管理
- 伤害处理后的击飞由 PlayerManager 协调

#### Phase 2: 关卡切换管理

**步骤1：扩展 GameManager 关卡功能**
- 在 GameManager 中实现 `load_level()`, `reload_current_level()` 等方法
- 注册所有关卡场景路径

**步骤2：重构 title.gd / gameclear.gd / player.gd**
- 移除直接的 `change_scene_to_file` 调用
- 改为 `GameManager.load_level("level_id")` 或 `GameManager.return_to_title()`

#### Phase 3: 玩家控制器拆分

**拆分前**：`player.gd` 包含所有逻辑

**拆分后**：
- `player.gd`：只保留物理处理和输入响应
- `PlayerAnimationController`：动画状态管理
- `PlayerInputHandler`：输入缓冲和映射
- `PlayerEffectHandler`：击飞、状态异常对移动的影响

#### Phase 4: 场景内调度器（按需实现）

**实现 SceneManager 子类**（有需要时）：
- 在需要复杂事件调度的关卡中创建自定义 SceneManager
- 实现 `_on_scene_enter()`, `trigger_event()` 等方法
- 用于管理场景级别的演出、过场动画、事件触发

**目前作为占位符**，简单关卡无需使用

---

## 四、文件结构调整

```
scripts/
├── autoload/                    # 自动加载的 Manager 单例
│   ├── game_manager.gd          # 游戏流程 + 关卡切换
│   ├── player_manager.gd
│   ├── level_manager.gd
│   ├── save_manager.gd
│   └── ui_manager.gd            # UI 管理
│
├── scene/                       # 场景调度相关
│   ├── scene_manager.gd         # SceneManager 基类（供场景继承）
│   └── levels/                  # 具体关卡的 SceneManager 实现
│       └── level_01_manager.gd
│
├── player/                      # 玩家相关脚本
│   ├── player_controller.gd     # 原 player.gd 重构
│   ├── player_state.gd          # 原 Playerstates.gd 重构
│   ├── player_input.gd          # 输入处理（新增）
│   └── player_effects.gd        # 效果处理（新增）
│
├── enemies/                     # 敌人相关脚本
│   ├── base_enemy.gd            # 敌人基类（新增）
│   ├── white_cell.gd            # 原 whitecell.gd
│   └── enemy_bullet.gd          # 原 wc_bullets.gd
│
├── hazards/                     # 陷阱/危险物
│   ├── base_hazard.gd           # 陷阱基类（新增）
│   ├── spike.gd                 # 原 spike.gd 重构
│   └── sticky_pool.gd           # 原 sticky_poor.gd 重构
│
├── ui/                          # UI 相关
│   ├── title_screen.gd          # 原 title.gd
│   ├── game_clear.gd            # 原 gameclear.gd
│   └── hud.gd                   # 游戏内 HUD（新增）
│
└── utils/                       # 工具类
    ├── constants.gd             # 游戏常量（重力等）
    └── signal_bus.gd            # 全局信号总线（可选）
```

---

## 五、关键设计决策

### 5.1 如何处理玩家伤害？

**方案A**：PlayerManager 直接修改玩家状态（推荐）
```gdscript
# 敌人调用
PlayerManager.apply_damage(damage_data)

# PlayerManager 内部
func apply_damage(data: Dictionary) -> void:
    var player = get_player()
    if not player:
        return

    # 1. 更新 PlayerState 数据
    var state = player.get_state()
    var final_knockback = state.calculate_damage(data)

    # 2. 应用击飞效果
    player.apply_knockback(final_knockback, data.get("direction"))

    # 3. 触发全局信号
    Events.player_damaged.emit(data)
```

**优势**：敌人不需要知道玩家的内部结构，所有伤害逻辑集中管理。

### 5.2 异常状态（粘液/虚弱）如何处理？

当前设计：PlayerState 管理计时器，player.gd 查询状态并修改摩擦力。

**改进设计**：
- PlayerState 管理状态和计时器（不变）
- 创建 `StatusEffectController` 处理状态对属性的影响
- 使用 Observer 模式：状态改变时通知控制器更新玩家属性

```gdscript
# 在 PlayerState 中
func apply_sticky_effect():
    is_sticky = true
    sticky_recover_timer.start(5.0)
    status_changed.emit("sticky", true)  # 通知监听者

# 在 PlayerController 中
func _on_status_changed(status: String, active: bool):
    match status:
        "sticky":
            _update_friction()
```

### 5.3 存档数据包含什么？

```gdscript
# save_data 结构
{
    "version": 1,
    "timestamp": "2026-02-14T10:30:00",
    "current_level": "level_1",
    "last_checkpoint": {"x": 100.5, "y": 200.0},
    "player": {
        "cloth": 2,
        "stamina": 100,
        "status_effects": []
    },
    "level_state": {
        "defeated_enemies": [],
        "collected_items": []
    }
}
```

---

## 六、实施建议

### 6.1 实施顺序

1. **Week 1**: 创建基础 Manager 框架（GameManager, PlayerManager）
2. **Week 2**: 重构玩家伤害系统，解耦敌人/陷阱脚本
3. **Week 3**: 重构 title.gd / gameclear.gd，统一关卡切换
4. **Week 4**: 实现存档系统（SaveManager, LevelManager）
5. **Week 5**: 代码清理、测试、Bug 修复

### 6.2 风险点

- **存档兼容性问题**：如果重构过程中需要修改 PlayerState 的数据结构，要确保存档系统能处理版本迁移
- **信号连接丢失**：重构时要小心检查所有信号连接，特别是 PlayerState 的信号
- **物理行为改变**：重构 player.gd 时要确保移动参数完全一致

### 6.3 向后兼容策略

- 保留旧的 `Global_settings` 和 `Playerstates` 作为过渡
- 逐步迁移，每次只重构一个模块
- 每次重构后都进行完整测试

---

## 七、附录：当前代码中的具体问题列表

### 7.1 代码风格问题

| 文件 | 问题 |
|------|------|
| `player.gd` | `JUMP_STEAGTH` 拼写错误（应为 STRENGTH） |
| `player.gd` | 混用 Tab 和空格缩进 |
| `spike.gd` | 使用 4 空格缩进，其他文件使用 Tab |
| `whitecell.gd` | `set_H_direction` 命名风格不一致（应 snake_case） |

### 7.2 逻辑问题

| 文件 | 问题 | 严重程度 |
|------|------|----------|
| `player.gd` | 游戏结束后在 `_on_state_gameover` 中检测输入，但只在信号触发的那一帧执行 | 高 |
| `player.gd` | 击飞方向硬编码为 `Vector2(-1, -0.4)`，应该从伤害来源方向计算 | 中 |
| `whitecell.gd` | `set_H_direction` 逻辑错误：`direction.x < 0` 时设为 1，否则设为 -1，应该反过来 | 中 |
| `sticky_poor.gd` | 先调用 `take_damage` 造成伤害，再调用 `apply_sticky_effect`，但 `take_damage` 也可能触发虚弱状态 | 低 |

### 7.3 性能问题

| 文件 | 问题 |
|------|------|
| `player.gd` | 每帧访问 `state.is_sticky`，应该缓存 |
| `whitecell.gd` | 每帧计算 `sin(time_elapsed * PI / 2)`，可以优化 |
| `wc_bullets.gd` | 使用 `_physics_process` 更新位置，但子弹是简单的直线运动，可以用 `_process` |

---

## 八、总结

### 当前架构的主要问题
1. **紧耦合**：敌人/陷阱直接硬编码访问玩家节点结构
2. **职责混乱**：PlayerState 越界处理击飞逻辑
3. **代码分散**：场景切换逻辑散落各处
4. **扩展性差**：难以添加新功能（存档、关卡切换、对象池）

### Manager 范式的核心收益
1. **解耦**：敌人只需要知道 `PlayerManager.apply_damage()`，不需要知道玩家结构
2. **集中管理**：关卡切换、存档、游戏状态、UI 都通过专门的 Manager 处理
3. **按需调度**：SceneManager 作为场景内调度器，只有需要时才实现，不增加无用复杂度
4. **UI 统一管理**：所有界面通过 UIManager 控制，实现自动数据同步和导航
5. **易于扩展**：新增 Manager 不会破坏现有代码
6. **便于测试**：Manager 可以单独测试，可以 Mock

### 推荐的第一个重构步骤
建议从 **创建 PlayerManager 并重构伤害系统** 开始，因为这是当前耦合最严重的地方，解耦后能为后续重构奠定良好基础。
